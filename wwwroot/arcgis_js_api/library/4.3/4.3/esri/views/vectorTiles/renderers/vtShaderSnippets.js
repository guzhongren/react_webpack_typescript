// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.3/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/vectorTiles/renderers/Shaders.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\x3c!--\r\n  Add your GLSL snippets to this file. You should start from\r\n  importing your old GLSL files. For instance, if you have a\r\n  file such as myShader.vs.glsl you should create a new \x3csnippet name\x3d"myShaderVS"\x3e\r\n  and then copy and paste the GLSL source as the content. You will then convert your\r\n  code to use the {@link module:esri/views/vectorTiles/renderers/vtShaderSnippets vtShaderSnippets}\r\n  instance to access the GLSL code, instead of importing it directly with require("dojo/text!...").\r\n--\x3e\r\n\x3csnippets\x3e\r\n\r\n  \x3csnippet name\x3d"foobarVS"\x3e\r\n  \x3c/snippet\x3e\r\n\r\n  \x3csnippet name\x3d"foobarFS"\x3e\r\n  \x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n\r\n',
"url:esri/views/vectorTiles/renderers/shaders/background.vs.glsl":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform mediump vec2 u_normalized_origin;\r\nuniform mediump float u_coord_range;\r\nuniform mediump float u_depth;\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\r\n}\r\n","url:esri/views/vectorTiles/renderers/shaders/background.fs.glsl":"uniform lowp vec4 u_color;\r\nvoid main() {\r\n  gl_FragColor \x3d u_color;\r\n}",
"url:esri/views/vectorTiles/renderers/shaders/lineShader.vs.glsl":"/* The implementation of the renderer is based on the article and implementation of MB described here:\r\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\r\n*/\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_offsetAndNormal;\r\nattribute float a_accumulatedDistance;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n// the inset and outset of the line\r\nuniform mediump float u_lineHalfWidth;\r\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\r\nvarying mediump vec2 v_normal;\r\n// the accumulated distance along the line. We need this information in order to render the dashes.\r\nvarying highp float v_accumulatedDistance;\r\n\r\nconst float scale \x3d 1.0 / 31.0;\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_offsetAndNormal.zw;\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec2 dist \x3d u_lineHalfWidth * a_offsetAndNormal.xy * scale;\r\n\r\n  // transform the vertex\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\r\n\r\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\r\n  v_accumulatedDistance \x3d a_accumulatedDistance;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/lineShader.fs.glsl":"/* The implementation of the renderer is based on the article and implementation of MB described here:\r\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\r\n*/\r\n\r\nuniform mediump float u_lineHalfWidth;\r\nuniform lowp vec4 u_color;\r\nuniform mediump vec2 u_dasharray;\r\nuniform lowp float u_blur;\r\n\r\nvarying mediump vec2 v_normal;\r\nvarying highp float v_accumulatedDistance;\r\n\r\nvoid main()\r\n{\r\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\r\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\r\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\r\n  mediump float fragDist \x3d length(v_normal) * u_lineHalfWidth;\r\n\r\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\r\n  // We need to count for both sides of the line.\r\n  lowp float alpha \x3d clamp( min(fragDist + u_blur + 1.0, u_lineHalfWidth - fragDist) / u_blur, 0.0, 1.0);\r\n\r\n  // now calculate the dashes given the accumulated distance of the line:\r\n  // start with calculating a normalized position along the line\r\n  lowp float dashPos \x3d  mod(v_accumulatedDistance, u_dasharray.x + u_dasharray.y);\r\n\r\n  // calculate the contribution to the alpha of the dash part. It is provided by the shortest portion of the position along the dash.\r\n  // we must clamp since the value might be bigger than 1 or smaller than zero (when over a dash).\r\n  //   | \x3c--- pos along the dash part\r\n  // -------_______-------_______\r\n  // when the dashPos is over the 'gap' part of the dash u_dasharray.x - dashPos is negative and therefore the alpha will\r\n  // get clamped to zero.\r\n  // when u_dasharray.x - dashPos is positive, or when dashPos is smaller than 1.0, it gives us a soft edge to each dash part.\r\n  // along the direction of the line.\r\n  lowp float dashAlpha \x3d clamp( min(dashPos, u_dasharray.x - dashPos), 0.0, 1.0);\r\n\r\n  // if we don't have a no-data part to the dash then it is a solid line\r\n  dashAlpha \x3d max(sign(-u_dasharray.y), dashAlpha); //sign(-u_dasharray.y) \x3e 0.0 ? 1.0 : dashAlpha;\r\n  // finally multiply the fragment's alpha by the calculated dash-alpha\r\n  alpha *\x3d dashAlpha;\r\n\r\n  // output the fragment color\r\n gl_FragColor \x3d alpha * u_color;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/patternLineShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec4 a_offsetAndNormal;\r\nattribute float a_accumulatedDistance;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n// the inset and outset of the line\r\nuniform mediump float u_lineHalfWidth;\r\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\r\nvarying mediump vec2 v_normal;\r\n// the accumulated distance along the line. We need this information in order to render the dashes.\r\nvarying highp float v_accumulatedDistance;\r\n\r\nconst float scale \x3d 1.0 / 31.0;\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_offsetAndNormal.zw;\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec2 dist \x3d u_lineHalfWidth * a_offsetAndNormal.xy * scale;\r\n\r\n  // transform the vertex\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\r\n\r\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\r\n  v_accumulatedDistance \x3d a_accumulatedDistance;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/patternLineShader.fs.glsl":"uniform mediump float u_lineHalfWidth;\r\nuniform lowp float u_blur;\r\nuniform lowp float u_opacity;\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform mediump vec2 u_spriteSize;\r\nuniform sampler2D u_texture;\r\n\r\nvarying mediump vec2 v_normal;\r\nvarying highp float v_accumulatedDistance;\r\n\r\nvoid main()\r\n{\r\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\r\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\r\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\r\n  mediump float fragDist \x3d length(v_normal) * u_lineHalfWidth;\r\n\r\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\r\n  // We need to count for both sides of the line.\r\n  lowp float alpha \x3d clamp( min(fragDist + u_blur + 1.0, u_lineHalfWidth - fragDist) / u_blur, 0.0, 1.0);\r\n  // add the line's opacity to the alpha\r\n  alpha *\x3d u_opacity;\r\n\r\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance aliong the line\r\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\r\n  mediump float relativeTexX \x3d mod(v_accumulatedDistance / u_spriteSize.x, 1.0);\r\n\r\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\r\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\r\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\r\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\r\n  //              | -\x3e linwe-width / 2\r\n  //      - - - - - - - - - - - - - -\r\n  //              | -\x3e linwe-width / 2\r\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\r\n\r\n  mediump float relativeTexY \x3d 0.5 + (v_normal.y * u_lineHalfWidth / (0.5 * u_spriteSize.y));\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\r\n\r\n  // get the color from the texture\r\n  lowp vec4 color \x3d texture2D(u_texture, texCoord);\r\n\r\n  // 'un-premultiply' the color\r\n  lowp float inv_alpha \x3d (1.0 / clamp(color.a, 0.00390625, 1.0));\r\n  // finally write the fragment value\r\n  gl_FragColor \x3d alpha * color;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/lineJoinShader.vs.glsl":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform highp float u_depth;\r\nuniform highp vec2 u_screen;\r\nuniform mediump float u_size;\r\nuniform mediump float u_pixelRatio;\r\n\r\nvarying mediump vec2 v_vertexPosition;\r\n\r\nvoid main()\r\n{\r\n  gl_PointSize \x3d u_pixelRatio * u_size;\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0);\r\n\r\n  // calculate the vertex position in pixels (we need to add one in order to shift the origin from the center of the viewport)\r\n  v_vertexPosition \x3d (gl_Position.xy + 1.0) * u_screen;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/lineJoinShader.fs.glsl":"uniform lowp vec4 u_color;\r\nuniform mediump float u_lineHalfWidth;\r\nuniform mediump float u_oneOverPixelRatio;\r\n\r\nvarying mediump vec2 v_vertexPosition;\r\n\r\nvoid main()\r\n{\r\n  // get the distance of the current fragment from the actual vertex\r\n  mediump float fragDist \x3d length(v_vertexPosition - u_oneOverPixelRatio * gl_FragCoord.xy);\r\n\r\n  // rounding the quare: calculate the alpha given the difference between the line-width and the distance of the fragment\r\n  // from the center-line. We will end up with a nice round circle with a soft edge.\r\n  lowp float alpha \x3d clamp(u_lineHalfWidth - fragDist, 0.0, 1.0);\r\n\r\n  // finally output the fragment color\r\n  gl_FragColor \x3d alpha * u_color;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/lineJoinQuadShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp mat4 u_extrudeMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform highp float u_depth;\r\n// The width/height of the screen\r\nuniform mediump vec2 u_screen;\r\n// u_size is the diameter of the join in tile units\r\nuniform mediump float u_size;\r\n\r\nvarying mediump vec2 v_fragmentOffset;\r\n\r\nvoid main()\r\n{\r\n  // calculate the offset in pixels from the join's center to the vertex\r\n  highp vec2 dist \x3d u_size * a_vertexOffset;\r\n\r\n  // calculate the position of the join's center in normalized coordinates\r\n  highp vec4 center_pos \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0);\r\n\r\n  // offset in normalized display units\r\n  highp vec4 vertex_offset \x3d u_extrudeMatrix * vec4(dist, 0.0, 0.0);\r\n\r\n  // calculate the vertex offset in windows coordinates\r\n  v_fragmentOffset \x3d u_screen * vertex_offset.xy;\r\n\r\n  // finally calculate the vertex position\r\n  gl_Position \x3d center_pos + vertex_offset;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/lineJoinQuadShader.fs.glsl":"uniform lowp vec4 u_color;\r\nuniform mediump float u_lineHalfWidth;\r\n\r\nvarying mediump vec2 v_fragmentOffset;\r\n\r\nvoid main()\r\n{\r\n  // Calculate the antialiasing fade factor\r\n  lowp float alpha \x3d clamp(u_lineHalfWidth * u_lineHalfWidth - dot(v_fragmentOffset, v_fragmentOffset), 0.0, 1.0);\r\n  //lowp float alpha  \x3d 1.0 - smoothstep(u_lineHalfWidth - 0.25, u_lineHalfWidth + 0.25, dist);\r\n  // YF: if needed w can also use a smoothstep around the edge of the circle and use a single pixel or so as the edge width\r\n\r\n  // finally output the fragment color\r\n  gl_FragColor \x3d alpha * u_color;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/solidFillShader.vs.glsl":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\n\r\nvoid main()\r\n{\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\r\n}\r\n","url:esri/views/vectorTiles/renderers/shaders/solidFillShader.fs.glsl":"uniform lowp vec4 u_color;\r\nvoid main()\r\n{\r\n  gl_FragColor \x3d u_color;\r\n}",
"url:esri/views/vectorTiles/renderers/shaders/patternFillShader.vs.glsl":"uniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump mat3 u_pattern_matrix; // can we use meduim precision??\r\n\r\nattribute vec2 a_pos;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\nvoid main()\r\n{\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0);\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  // (-4k to 8k -1) to texture coordinates.\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/patternFillShader.fs.glsl":"uniform lowp float u_opacity;\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform sampler2D u_texture;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\nvoid main()\r\n{\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d u_opacity * color;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/fillOutlineShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec2 a_offset;\r\nattribute vec2 a_xnormal;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp mat4 u_extrudeMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_outline_width;\r\n\r\nvarying lowp vec2 v_normal;\r\n\r\nconst float scale \x3d 1.0 / 15.0;\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_xnormal;\r\n\r\n   // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n    // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec4 dist \x3d vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\r\n\r\n  // Remove the texture normal bit of the position before scaling it with the\r\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\r\n  // because we're extruding the line in pixel space, regardless of the current\r\n  // tile's zoom level.\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/fillOutlineShader.fs.glsl":"uniform lowp vec4 u_color;\r\nvarying mediump vec2 v_normal;\r\n\r\nvoid main()\r\n{\r\n  // Calculate the distance of the pixel from the line in pixels.\r\n  lowp float dist \x3d abs(v_normal.y);\r\n\r\n  lowp float alpha \x3d smoothstep(1.0, 0.0, dist);\r\n  gl_FragColor \x3d alpha * u_color;\r\n}\r\n","url:esri/views/vectorTiles/renderers/shaders/iconShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\nattribute vec4 a_tex;\r\nattribute vec4 a_levelInfo;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n// the map's rotation from the north\r\nuniform mediump float u_mapRotation;\r\nuniform mediump float u_level;\r\n// indicate whether the current set of iconst should be kept upright when the map is rotated\r\nuniform lowp float u_keepUpright;\r\n// the rate of the change in the opacity (fade) of the icons\r\nuniform mediump float u_fadeSpeed;\r\n// the low level we transition (to/from)\r\nuniform mediump float u_minfadeLevel;\r\n// the high level we transition (to/from)\r\nuniform mediump float u_maxfadeLevel;\r\n// the amount of fade given teh current time past the last recorded level\r\nuniform mediump float u_fadeChange;\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_opacity;\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying lowp vec2 v_tex;\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\r\n// by 16 and then at the shader devide by the same number\r\nconst float offsetPrecision \x3d 1.0 / 32.0;\r\n\r\nvoid main()\r\n{\r\n  mediump float a_labelMinLevel \x3d a_levelInfo[0];\r\n  mediump float a_angle        \x3d a_levelInfo[1];\r\n  mediump float a_minLevel    \x3d a_levelInfo[2];\r\n  mediump float a_maxLevel    \x3d a_levelInfo[3];\r\n\r\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\r\n  mediump float delta_z \x3d 0.0;\r\n\r\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\r\n  mediump float rotated \x3d mod(a_angle - u_mapRotation, 256.0);\r\n  delta_z +\x3d (1.0 - step(u_keepUpright,0.0)) * step(65.0,rotated) * (1.0 - step(193.0,rotated)); //ie. z +\x3d (flip \x3e 0) \x26\x26 (65 \x3c\x3d rotated) \x26\x26 (rotated \x3c 193)\r\n\r\n  // u_level is the current service level adjusted for the change in font size\r\n  delta_z +\x3d 1.0 - step(a_minLevel, u_level); // Test if (level \x3c minLevel)\r\n  delta_z +\x3d step(a_maxLevel, u_level); // Test if (maxLevel \x3c\x3d level)\r\n\r\n  // calculate the alpha given the change in the fade and the fade-speed\r\n  lowp float alpha \x3d clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\r\n\r\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\r\n  v_transparency \x3d (u_fadeSpeed \x3e\x3d 0.0 ? alpha : 1.0 - alpha);\r\n\r\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\r\n  if (u_maxfadeLevel \x3c a_labelMinLevel)\r\n  {\r\n      v_transparency \x3d 0.0;\r\n  }\r\n  if (u_minfadeLevel \x3e\x3d a_labelMinLevel)\r\n  {\r\n      v_transparency \x3d 1.0;\r\n  }\r\n\r\n  // if label had been faded out, clip it\r\n  delta_z +\x3d step(v_transparency, 0.0);\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\r\n  v_tex \x3d a_tex.xy / u_mosaicSize;\r\n\r\n  v_transparency *\x3d u_opacity;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/iconShader.fs.glsl":"uniform lowp sampler2D u_texture;\r\nvarying lowp vec2 v_tex;\r\nvarying lowp float v_transparency;\r\n\r\nvoid main()\r\n{\r\n  lowp vec4 color \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d v_transparency * color;\r\n}\r\n","url:esri/views/vectorTiles/renderers/shaders/sdfShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\nattribute vec4 a_tex;\r\nattribute vec4 a_levelInfo;\r\n\r\n// attribute bool a_visible; // --\x3e a one bit controlling the visibility of the vertex\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n// the map's rotation from the north\r\nuniform mediump float u_mapRotation;\r\nuniform mediump float u_level;\r\n// indicate whether the current set of iconst should be kept upright when the map is rotated\r\nuniform lowp float u_keepUpright;\r\n// the rate of the change in the opacity (fade) of the icons\r\nuniform mediump float u_fadeSpeed;\r\n// the low level we transition (to/from)\r\nuniform mediump float u_minfadeLevel;\r\n// the high level we transition (to/from)\r\nuniform mediump float u_maxfadeLevel;\r\n// the amount of fade given teh current time past the last recorded level\r\nuniform mediump float u_fadeChange;\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_opacity;\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying lowp vec2 v_tex;\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\r\n// by 16 and then at the shader devide by the same number\r\nconst float offsetPrecision \x3d 1.0 / 32.0;\r\n\r\nvoid main()\r\n{\r\n  mediump float a_labelMinLevel \x3d a_levelInfo[0];\r\n  mediump float a_angle        \x3d a_levelInfo[1];\r\n  mediump float a_minLevel    \x3d a_levelInfo[2];\r\n  mediump float a_maxLevel    \x3d a_levelInfo[3];\r\n\r\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\r\n  mediump float delta_z \x3d 0.0;\r\n\r\n  // TODO: force clipping the vertex in case that the vertex isn't visible\r\n  //delta_z +\x3d a_visible ? 0.0 : 1.0;\r\n\r\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\r\n  mediump float rotated \x3d mod(a_angle - u_mapRotation, 256.0);\r\n  delta_z +\x3d (1.0 - step(u_keepUpright, 0.0)) * step(65.0, rotated) * (1.0 - step(193.0, rotated)); //ie. z +\x3d (flip \x3e 0) \x26\x26 (65 \x3c\x3d rotated) \x26\x26 (rotated \x3c 193)\r\n\r\n  // u_level is the current service level adjusted for the change in font size\r\n  delta_z +\x3d 1.0 - step(a_minLevel, u_level); // Test if (level \x3c minLevel)\r\n  delta_z +\x3d step(a_maxLevel, u_level); // Test if (maxLevel \x3c\x3d level)\r\n\r\n  // calculate the alpha given the change in the fade and the fade-speed\r\n  lowp float alpha \x3d clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\r\n\r\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\r\n  v_transparency \x3d (u_fadeSpeed \x3e\x3d 0.0 ? alpha : 1.0 - alpha);\r\n\r\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\r\n  if (u_maxfadeLevel \x3c a_labelMinLevel)\r\n  {\r\n      v_transparency \x3d 0.0;\r\n  }\r\n  if (u_minfadeLevel \x3e\x3d a_labelMinLevel)\r\n  {\r\n      v_transparency \x3d 1.0;\r\n  }\r\n\r\n  // if label has been faded out, clip it\r\n  delta_z +\x3d step(v_transparency, 0.0);\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\r\n  v_tex \x3d a_tex.xy / u_mosaicSize;\r\n\r\n  v_transparency *\x3d u_opacity;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/sdfShader.fs.glsl":"uniform lowp sampler2D u_texture;\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_edgeDistance;\r\nuniform mediump float u_edgeWidth;\r\n\r\nvarying lowp vec2 v_tex;\r\nvarying lowp float v_transparency;\r\n\r\n// this is taken from http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\r\n// and https://www.mapbox.com/blog/text-signed-distance-fields/\r\n// http://metalbyexample.com/rendering-text-in-metal-with-signed-distance-fields/\r\n\r\nvoid main()\r\n{\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  mediump float alpha \x3d smoothstep(u_edgeDistance - u_edgeWidth, u_edgeDistance + u_edgeWidth, dist) * v_transparency;\r\n\r\n  gl_FragColor \x3d alpha * u_color;\r\n\r\n// YF: this code allow having both a fill and an outline colors combined in a single pass\r\n//  lowp float geometryAlpha \x3d smoothstep(0.75 - 0.21, 0.75 + 0.21, dist) * v_transparency;\r\n//  lowp vec4 geometryColor \x3d vec4(u_color.rgb, geometryAlpha * u_color.a);\r\n//\r\n//  if (true) {\r\n//    lowp float haloAlpha \x3d smoothstep(0.0 - 0.1, 0.0 + 0.1, dist) * v_transparency;\r\n//    lowp vec4 haloColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n//    haloColor \x3d vec4(haloColor.rgb, haloAlpha);\r\n//\r\n//    // calculate the composite color\r\n//    lowp float compositeAlpha \x3d geometryColor.a + haloColor.a * (1.0 - geometryColor.a);\r\n//    lowp vec3 compositeColor \x3d vec3(geometryColor) * geometryColor.a + vec3(haloColor) * haloColor.a * (1.0 - geometryColor.a);\r\n//    compositeColor /\x3d compositeAlpha;\r\n//    gl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n//  }\r\n//  else {\r\n//    gl_FragColor \x3d geometryColor;\r\n//  }\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/tileInfo.vs.glsl":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform mediump vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_coord_ratio;\r\nuniform mediump vec2 u_delta; // in tile coordinates\r\nuniform mediump vec2 u_dimensions; // in tile coordinates\r\n\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main() {\r\n  mediump vec2 offests \x3d u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\r\n\r\n  v_tex \x3d a_pos;\r\n}\r\n",
"url:esri/views/vectorTiles/renderers/shaders/tileInfo.fs.glsl":"uniform mediump sampler2D u_texture;\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main(void) {\r\n  lowp vec4 color \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d 0.75 * color;\r\n}\r\n"}});
define("require exports ../../webgl/ShaderSnippets dojo/text!./Shaders.xml dojo/text!./shaders/background.vs.glsl dojo/text!./shaders/background.fs.glsl dojo/text!./shaders/lineShader.vs.glsl dojo/text!./shaders/lineShader.fs.glsl dojo/text!./shaders/patternLineShader.vs.glsl dojo/text!./shaders/patternLineShader.fs.glsl dojo/text!./shaders/lineJoinShader.vs.glsl dojo/text!./shaders/lineJoinShader.fs.glsl dojo/text!./shaders/lineJoinQuadShader.vs.glsl dojo/text!./shaders/lineJoinQuadShader.fs.glsl dojo/text!./shaders/solidFillShader.vs.glsl dojo/text!./shaders/solidFillShader.fs.glsl dojo/text!./shaders/patternFillShader.vs.glsl dojo/text!./shaders/patternFillShader.fs.glsl dojo/text!./shaders/fillOutlineShader.vs.glsl dojo/text!./shaders/fillOutlineShader.fs.glsl dojo/text!./shaders/iconShader.vs.glsl dojo/text!./shaders/iconShader.fs.glsl dojo/text!./shaders/sdfShader.vs.glsl dojo/text!./shaders/sdfShader.fs.glsl dojo/text!./shaders/tileInfo.vs.glsl dojo/text!./shaders/tileInfo.fs.glsl".split(" "),function(c,
F,d,e,f,g,h,k,l,m,n,p,q,r,t,u,v,w,x,y,z,A,B,C,D,E){function a(a,c){b+='\x3csnippet name\x3d"'+a+'"\x3e\x3c![CDATA[';b+=c;b+="]]\x3e\x3c/snippet\x3e"}var b="",b=b+'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e',b=b+"\x3csnippets\x3e";a("backgroundVS",f);a("backgroundFS",g);a("lineShaderVS",h);a("lineShaderFS",k);a("patternLineShaderVS",l);a("patternLineShaderFS",m);a("lineJoinShaderVS",n);a("lineJoinShaderFS",p);a("lineJoinQuadShaderVS",q);a("lineJoinQuadShaderFS",r);a("solidFillShaderVS",t);
a("solidFillShaderFS",u);a("patternFillShaderVS",v);a("patternFillShaderFS",w);a("fillOutlineShaderVS",x);a("fillOutlineShaderFS",y);a("iconShaderVS",z);a("iconShaderFS",A);a("sdfShaderVS",B);a("sdfShaderFS",C);a("tileInfoVS",D);a("tileInfoFS",E);b+="\x3c/snippets\x3e";c=new d;d.parse(b,c);d.parse(e,c);return c});